citation()
0.0005*100^3
seq(1, 180, by = 14)
seq(0, 180, by = 14)
devtools::install_github("ropensci/rfishbase@sac-null")#
 library(rfishbase)#
  library(calibrate)#
 library(reshape)#
library(wesanderson)#
#
elasmos <- species_list(Class = "Elasmobranchii")#
herrings <- species_list(Order = "Clupeiformes")#
scorps <- species_list(Order = "Scorpaeniformes")#
flounder <- species_list(Order = "Pleuronectiformes")#
lophius <- species_list(Order = "Lophiiformes")#
 salmon <- species_list(Order = "Salmoniformes")#
mackerel <- species_list(Family = "Carangidae")   #
snapper <- species_list(Family = "Lutjanidae")#
striper <- species_list(Family = "Percichthyidae")#
walleye <- species_list(Family = "Percidae")#
croaker <- species_list(Family = "Scianidae")#
tunas <- species_list(Family = "Scombridae") #
sparids <- species_list(Family = "Sparidae")#
 swordfish <- species_list(Family = "Xiphiidae")#
seahorses<-species_list(Family = "Syngnathidae")
install.packages("rfishbase")
library(rfishbase)
elasmos <- species_list(Class = "Elasmobranchii")
install.packages("rfishbase-package")
elasmos <- species_list(Class = "Elasmobranchii")
juvsurv <- fecundity(masterlist)#
 adultsurv <- maturity(masterlist)
runif(0, 10, 40)
?runif
runif(40, 0, 10)
write.csv(round(runif(40, 0, 10)), "salamander_counts.csv")
rnorm(40, mean=8, sd=1)
rnorm(40, mean=8, sd=2)
round(rnorm(40, mean=8, sd=2))
round(rnorm(40, mean=2, sd=2))
round(rnorm(40, mean=4, sd=2))
read.csv("~/Desktop/exam.csv")
x <- read.csv("~/Desktop/exam.csv")
hist(x[, 1])
hist(x[-66, 1])
hist(x[-66, 1], main="Assignment 2")
hist(x[, 2], main="Exam 1")
hist(x[, 2], main="Exam 1", xlab="Points")
hist(x[-66, 1], main="Assignment 2", xlab="Points")
0.9^4
1-0.1^4
0.1^4
(size[index]^3 + g_allo[index,i]*(state[index]/(a*scale)))^(1/3)
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv")
data
head(data)
na.omit(data)
head(na.omit(data))
colSums(as.numeric(data))
class(data)
apply(data, 2, as.numeric)
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", string.as.factors =T)
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", strings.as.factors =T)
?strings
??strings
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)
data
colSums(data)
colSums(as.numeric(data)
)
colSums(as.matrix(as.numeric(data))
)
data
head(data)
class(data)
dmat <- matrix(data[, c(1, 2:16)])
dmat
dmat <- matrix(data[, c(1, 3:16)])
mat
dmat
colSums(as.matrix(as.numeric(as.character(data)))
)
as.matrix(as.numeric(as.character(data)))
dmat <-(as.numeric(as.character(data)))
dmat
data
read_csv(data)
datamat <- data==1
datamat
data <- as.character(data)#
data[data==""] <- NA
data
head(dat)
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)
class(data)
data <- as.character(data)#
data[data==""] <- NA
data
matrix(data, ncol=16)
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)
data[data==""]<- "NA"
warnings
data[data==""]<- NA
data
dim(data)
data<- data[, -2]
data
dim(data)
rowSums(data)
rowSums(as.numeric(data)
)
rowSums(as.numeric(as.character(data)))
which(data!="NA")
data[data!=NA] <- 1
data
data[data!="NA"] <- 1
warnings
warnings()
dim(data)
x<- ifelse(data!="NA", 1, 0)
matrix(x, nrow=79, ncol=15)
x<- ifelse(data!=NA, 1, 0)
x<- ifelse(data!="NA", 1, 0)
x<- ifelse(data!=NA, 1, 0)
matrix(x, nrow=79, ncol=15)
x<- which(data!="NA")
matrix(x, nrow=79, ncol=15)
x<- which(data!=NA)
matrix(x, nrow=79, ncol=15)
is.na(dat)
is.na(data)
data
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)
is.na(data)
dat
data
numdata <- ifelse(data=="", 0, 1)
numdata
numdata<- numdata[, -2]
pts <- rowSums(numdata)
pts
names(pts)<- data[, 1]
pts
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)w
write.csv(pts, file="mid_semester_attendance.csv")
names_pts<-cbind(data[, 1], pts)
write.csv(names_pts, file="mid_semester_attendance.csv")
pts
.9^10
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)#
numdata <- ifelse(data[, -2]=="", 0, 1)#
  pts <- rowSums(numdata)#
  write.csv(cbind(data[, 2], pts), file="dec_7_attendance.csv")
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)#
numdata <- ifelse(data[, -2]=="", 0, 1)#
  pts <- rowSums(numdata)#
  write.csv(cbind(data[, 2], pts), file="~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/dec_7_attendance.csv")
head(data)
data[,2]
data<-read.csv("~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/attendance.csv", stringsAsFactors =T)#
numdata <- ifelse(data[, -2]=="", 0, 1)#
  pts <- rowSums(numdata)#
  write.csv(cbind(data[, 2], pts), file="~/Dropbox/Current Files/Teaching/FIW 4414/Pop Dy 2020/dec_7_attendance.csv")
cbind(data[, 2], pts)
data[, 2]
cbind[data,2], pts
cbind(data[,2], pts)
103/110
sum(2, 2)
sum(2, 2, 3, 3, 5, 1, 3, 3, 2, 2, 5, 1, 5)
sum(2, 2, 3, 5, 2, 4, 4, 5, 4)
sum(2, 2, 3, 10, 4, 1, 3, 4, 2, 2, 4, 1, 3, 1)
sum(2, 2, 3, 5, 3.5, 1, 3, 4, 2, 1, 5, 1, 3 ,1)
sum(10, 4, 6, 4, 4, 3, 3, 5, 5, 2)
.2e+08
2e+07/3+e08
2e+07/3e+08
3e+08/2e+07
log(1.16)
1.17
log(1.17)
log(1.18)
1.19
log(1.19)
log(1.2)
100/80
100/81
100/82
100/83
100/84
log(100/83)
x <- matrix(nrow = 4, ncol = 4, data =  c(0, 0.8446, 0.8446, 0.8846, 0.6986, 0, 0, 0, 0, 0.5872, 0, 0, 0, 0, 0.2623, 0))
x
eigen(x)
install.packages("tidybayes")
install.package("posterior")
install.packages("posterior")
install.packages("tidybayes")
#!/usr/bin/env Rscript --vanilla#
#install.packages("fields")#
# library(fields)#
#rm(list = ls(all = TRUE))#
#
set.seed(1001)#
filepath <- "~/Desktop/group4/"#
#filepath <- "~/Desktop/test/"#
seasons = "YES"#
#
 f_h <- 4/12#
#
timebin=12#
 Temp <- 288.15#
  reprolimit=0.2#
  Kappa = 4/12  #
  Tmax = 18*timebin  #monthly stime steps, maximum lifespan is 18 years#
#describe temperature dependent costs#
k=1.3e-23#
E = 1.04e-19#
theta=0.66#
 coef1  =5e+16 ##normalization constant puts tuna SMR in the same ballpark as the costs Kitchell et al. (1978) Bioenergetic spectra of skipjack and yellowfin tunas, pp 359 IN Sharp G.D. and Dizon A.E. eds. The Physiological Ecology of Tunas, Academic press.  #
#
#physiological parameters#
a <- 5e-5 #from ICCAT 2015 BFT length-weight relationship#
Jdensity <-  4.2e+6 #J/kg #from Chapman et al. 2011#
b=1.8#
d = 2.4#
#
#STATE VARIABLES#
phi <- 1 # only 1 environment#
Lmax <- 400  #maximum size of 4 meters#
Lmin <- 1 #
Yindexmax <- 100 #maximum index of stores in state loop  #
#
storemax= 0.6 #proportion of structural mass that individuals can devote to energy storage#
storemin = 0.1#
thresholdsize <- 20#
####################################################################################################################################################################################################
###Lookup Tables - look up costs and food functions so they are not calculated every time#
#
###Sizespectra allow us to descripbe prey preference, encounter, consumption to predict prey availability and mass-specific mortality:#
  #total mass maximum in kg#
##Prey availability   #
phi_a <- 3 #from table 2.2 in Andersen book#
lam <- 1.95#
K_c=10 #from Table 2.2, this changes with season (and is scaled by Kappa)#
##mass dependent mortality#
 phi_p <- 0.07 #from table 2.2 in Andersen book#
f_0 <- 0.6 #somewhere between 0 and 1, but predators rarely caught with totally full stomach#
hprime <- 17.2#
#coefficient on the consumption rate from table 2.2#
met_mort <- -0.25 #the argument in Andersen book is that mass-specific rates such as mortality Jdensitys with the metabolic esp of 3/4 (Brown et al. 2004). #
#
#steepness of penalty to survival near EcritL threshold state value#
q = 5e-5 #
####ADD SEASONALITY IN RESOURCES AND FOOD TO SOME MONTHS#
if(seasons == "NO") {	#
	kmult <-   rep(1, timebin)   #
	raiseT <-      rep(0, timebin)  	#
		} else {#
		#hardcoded for timebin = 12#
	kmult <-    c(rep(3, 9), rep(1, 3))  #currently short breeding season with low resources#
	raiseT <-   c(rep(0,9), rep(9, 3))#currently raise T from 15 to 24#
#
		} #end if #
#
Mass <- a*(Lmin:Lmax)^3 #
#
mu<- phi_p*f_h*Mass^met_mort #note we are excluding "background" mortality that is independent of size.... #
#
Income = matrix(nrow = timebin, ncol = length(Mass))#
MTcosts = matrix(nrow = timebin, ncol = length(Mass))#
#
for (kap in 1:timebin) {#
  Income[kap, ] <- kmult[kap]*Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
  MTcosts[kap, ] <-coef1*(Mass)^theta*(exp(-E/(k*(Temp+raiseT[kap])))) #
}#
 # plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 2600000), col=4)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=4)#
# lines(MTcosts[1, ], lty=1, col=1, lwd=2)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=1)#
# lines(MTcosts[1, ], lty=1, col=2, lwd=2)#
# Income = Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
#   #
#  plot(Income)#
#  #
# ###plot metabolic cost functions for each temp to check they are sensible#
 #  matplot( ((1:length(Mass))), t((MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab="Metabolic rate in J/season", col=c(4, 3, "orange", 2, "dark red"))    #
##################################################################################################################################################################################################
#DYNAMIC MODEL: life history in a single environment#
#
#dynamic behaviors#
u <-  seq(0, 1, by = 0.1) #fraction stored (rest allocated to structure)#
#
r<-  seq(0, 1, by = 0.1) #fraction allocated to reproduction (rest is saved)#
#set up arrays to store fitness values  #
MaxF=array(dim=c(Yindexmax, Lmax, phi, Tmax),data=-1) #this will store the max fitness for every combination of state and times#
MaxF[,,,Tmax]=0 #Fill fitness of Tmax column with 0#
Vmat=array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#Vmat is the fitness value of all possible actions#
Vmat[,,,,,]=rep(-1, length(Vmat))#
Cmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
Fmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#store optimal behaviors#
optU=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
optR=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
#the dynamic loop:#
i <- Tmax-1	#
for (i in (Tmax-1):1) { #where i is time (age) in months#
Y <- 1#
 for (Y in 1:Yindexmax) { #for all values of Energy Stores in loop (unJdensityd)#
  #setTxtProgressBar(pb, Y) #progress bar tracks which value of Y we are on#
  L <- Lmin#
   for (L in Lmin:Lmax) { #for all possible values of Length#
    p <- 1#
   for (p in 1:phi) { #for every temp environment#
     			spawning <- "NO"#
    		month = ((i-1) %% 12) + 1 #for the seasonality convert time in months to specific season-month (1-12)#
			 if (raiseT[month] > 0) spawning <- "YES"#
			          #############################
          #calculate the critical stored energy needed for this length to be viable #
            Wstructure<-a*L^3 #  find structural mass in kg#
            Estores <-   Jdensity*a*Lmax^3*(Y^3)*storemax/(Yindexmax^3)#
            EcritL <- Wstructure*storemin*Jdensity#
            EstoresmaxL <-Wstructure*storemax*Jdensity #following Chapman et al#
            if (Estores > EstoresmaxL)  Estores <- EstoresmaxL #stored energy (Estores) capped at the maximum allowed (60% of the structural body mass in J) #
	        #two loops over allocation strategies:#
	        g <- 1#
	        for (g in 1:length(u)) { #fractional placeholder (placeholder variable so we can loop over non-integers)#
	            growth = u[g] #Convert integer loop index to fractional value for allocation     #
	        for(h in 1:length(r)) { #where r is fractional allocation to reproductive effort	#
	             if (spawning == "YES") {#
	           reprod = r[h]  #Convert integer loop index to fractional value for allocation#
	               } else 	reprod = 0 #
	           #check if this combination of allocation is viable, and this number of stores is adequate for this length: #
		          if (growth + reprod > 1 )   Vmat[Y,L, p, i, g, h]	<- 0 else #
		            { #given the above conditions are met calculate all states:#
		                Wstores<-Estores/Jdensity  #stored mass in kG#
		                Wtotal <- Wstores+Wstructure  #body mass in KG#
		                Estructure <- Wstructure*Jdensity #body structure in Joules#
		                Rlimit <- Estructure*reprolimit #rlimit in Joules#
		                #future state calculations		              #
		                EstoresP <- Estores*(1-reprod-growth) +Income[month, L]*Jdensity - MTcosts[month, L] #combines mass-dependent food intake and mass-dependent metabolic costs#
		                EstructureP <- Estructure + growth*Estores#
		                #WstructureP <- Wstructure + growth*Estores/Jdensity #
		                LengthP <- (L^3 + growth*(Estores /(a*Jdensity)) )^(1/3)#
		                EstoresmaxLP <- EstructureP*storemax #
		                EstoresP <- min(EstoresP, EstoresmaxLP) # this statement caps stores max storage allowed for that size#
		                EstoresP <- max(EstoresP, 0)	 #if future stored energy is negative, it is cut off at zero.   #
		              ####Interpolation of future fitness between non-integer values of stored energy#
		                YP <- ((EstoresP*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3) #convert future stores to a future state index on the Y scale#
		                YP_floor <- floor(YP)#
		                 dx <- YP - YP_floor#
		              if (ceiling(LengthP) > Lmax) Lindex <- Lmax else#
		                Lindex <- ceiling(LengthP)#
		              if(YP_floor >= Yindexmax )#
		              {#
		                  FutureFitness <- MaxF[Yindexmax,Lindex,p,i+1] } else {#
		              	    	  FutureFitness <- dx*MaxF[YP_floor+1, Lindex, p, i+1]#
		              	  if(YP_floor > 0) FutureFitness <- FutureFitness + (1-dx)*MaxF[YP_floor,Lindex,p,i+1] #
		              } #end else if#
		                 if (reprod*Estores > Rlimit) {#
		                    RealizedR <- Rlimit } else {#
		                        RealizedR <- reprod*Estores#
		                    } #
		                Ecrit_survival <- 1 /(1 + exp(- q*(Estores - EcritL))) #
		                Rlimit_smooth <-  (reprod * Estores)  / (1 + ((reprod*Estores) / Rlimit)) #
		                Vmat[Y,L, p, i, g, h]	<-  (Rlimit_smooth  + exp(-mu[L])*FutureFitness )*Ecrit_survival#
		                #Cmat[Y,L, p, i, g, h] <- Rlimit_smooth*Ecrit_survival#
		                #Fmat[Y,L, p, i, g, h] <- exp(-mu[L])*FutureFitness*Ecrit_survival#
	            		  } #end else if growth + reprod < 1 and EcritL < Estores	  		#
	         		 } #end h loop#
	      			 } #end g loop#
        #find and store the highest fitness from growth and reproduction combinations given the other values for length, stored energy, and age#
        MaxF[Y,L,p,i] <-  max(Vmat[Y,L, p, i, , ])#
        if(MaxF[Y,L,p,i] == 0)#
        {#
          optU[Y, L,p,i]=-1#
          optR[Y, L,p,i]=0#
        } else {#
        #find out the differences in fitness of all strategies from the maximum, #
        #use the mean if a tie, record the difference for later error introduction:#
        nStrats = length(u) * length(r)#
        cursor = 0#
        mult_u <- rep(NA, nStrats)#
        mult_r <- rep(NA, nStrats)#
        for (g in 1:length(u)) {#
          for(h in 1:length(r)) {#
            if (MaxF[Y, L,p,i] == Vmat[Y,L, p, i, g, h]) {#
              cursor = cursor + 1#
              mult_u[cursor] <- u[g]	   #record all behaviors that have the same fitness as the max.         #
              mult_r[cursor] <- r[h]#
            }  #end if#
          } # end 2nd h loop  #
        } #end 2nd g loop#
        eqGrowth = mult_u[1:cursor]#
        eqRepro = mult_r[1:cursor]#
        smallestRepro = min(eqRepro)#
        largestGrowth = max(eqGrowth[eqRepro == smallestRepro])#
        #take mean of all behaviors with same fitness as max#
        optU[Y, L,p,i]=largestGrowth#
        optR[Y, L,p,i]=smallestRepro#
        }#
    }	#end p loop#
  } #end L loop#
} #end Y loop#
#
} #end i loop#
#quartz()#
#par(mfrow=c(3,2))#
#gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
#image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
#image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
#image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
#image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
#image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
#image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")       #
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (reprod * state[index])  / (1 + ( reprod*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")  '
library(fields)
install.packages("fields")
library(fields)
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")  '
optR
image.plot(1:Lmax, 1:Amax, t(optU[,100, 1,]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Amax, t(optR[,100, 1,]),     ylab="State", xlab="Length", main="reproduction")
image.plot(1:Lmax, 1:Tmax, t(optU[,100, 1,]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Tmax, t(optR[,100, 1,]),     ylab="State", xlab="Length", main="reproduction")
dim((optU[,100, 1,]))
image.plot(1:Lmax, 1:(Tmax-1), t(optU[,100, 1,]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:(Tmax-), t(optR[,100, 1,]),     ylab="State", xlab="Length", main="reproduction")
image.plot(1:Lmax, 1:(Tmax-1), t(optU[,100, 1,]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:(Tmax-1), t(optR[,100, 1,]),     ylab="State", xlab="Length", main="reproduction")
dim(t(optU[,100, 1,]))
image.plot( 1:(Tmax-1), 1:100, t(optU[,100, 1,]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(  1:(Tmax-1), 1:100, t(optR[,100, 1,]),     ylab="State", xlab="Length", main="reproduction")
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")
sizedist
reproduction
reprod
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1
i=1
month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length
state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)
}
Estores
Ilo
g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)
repro
g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (reprod * state[index])  / (1 + ( reprod*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)
reproduction
#survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if
i = 2
for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (reprod * state[index])  / (1 + ( reprod*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop
idist
repro
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
#!/usr/bin/env Rscript --vanilla#
#install.packages("fields")#
# library(fields)#
#rm(list = ls(all = TRUE))#
#
set.seed(1001)#
filepath <- "~/Desktop/group3/"#
#filepath <- "~/Desktop/test/"#
seasons = "YES"#
#
 f_h <- 4/12#
#
timebin=12#
 Temp <- 288.15#
  reprolimit=0.2#
  Kappa = 4/12  #
  Tmax = 18*timebin  #monthly stime steps, maximum lifespan is 18 years#
#describe temperature dependent costs#
k=1.3e-23#
E = 1.04e-19#
theta=0.66#
 coef1  =5e+16 ##normalization constant puts tuna SMR in the same ballpark as the costs Kitchell et al. (1978) Bioenergetic spectra of skipjack and yellowfin tunas, pp 359 IN Sharp G.D. and Dizon A.E. eds. The Physiological Ecology of Tunas, Academic press.  #
#
#physiological parameters#
a <- 5e-5 #from ICCAT 2015 BFT length-weight relationship#
Jdensity <-  4.2e+6 #J/kg #from Chapman et al. 2011#
b=1.8#
d = 2.4#
#
#STATE VARIABLES#
phi <- 1 # only 1 environment#
Lmax <- 400  #maximum size of 4 meters#
Lmin <- 1 #
Yindexmax <- 100 #maximum index of stores in state loop  #
#
storemax= 0.6 #proportion of structural mass that individuals can devote to energy storage#
storemin = 0.1#
thresholdsize <- 20#
####################################################################################################################################################################################################
###Lookup Tables - look up costs and food functions so they are not calculated every time#
#
###Sizespectra allow us to descripbe prey preference, encounter, consumption to predict prey availability and mass-specific mortality:#
  #total mass maximum in kg#
##Prey availability   #
phi_a <- 3 #from table 2.2 in Andersen book#
lam <- 1.95#
K_c=10 #from Table 2.2, this changes with season (and is scaled by Kappa)#
##mass dependent mortality#
 phi_p <- 0.07 #from table 2.2 in Andersen book#
f_0 <- 0.6 #somewhere between 0 and 1, but predators rarely caught with totally full stomach#
hprime <- 17.2#
#coefficient on the consumption rate from table 2.2#
met_mort <- -0.25 #the argument in Andersen book is that mass-specific rates such as mortality Jdensitys with the metabolic esp of 3/4 (Brown et al. 2004). #
#
#steepness of penalty to survival near EcritL threshold state value#
q = 5e-5 #
####ADD SEASONALITY IN RESOURCES AND FOOD TO SOME MONTHS#
if(seasons == "NO") {	#
	kmult <-   rep(1, timebin)   #
	raiseT <-      rep(0, timebin)  	#
		} else {#
		#hardcoded for timebin = 12#
	kmult <-    c(rep(3, 9), rep(1, 3))  #currently short breeding season with low resources#
	raiseT <-   c(rep(0,9), rep(9, 3))#currently raise T from 15 to 24#
#
		} #end if #
#
Mass <- a*(Lmin:Lmax)^3 #
#
mu<- phi_p*f_h*Mass^met_mort #note we are excluding "background" mortality that is independent of size.... #
#
Income = matrix(nrow = timebin, ncol = length(Mass))#
MTcosts = matrix(nrow = timebin, ncol = length(Mass))#
#
for (kap in 1:timebin) {#
  Income[kap, ] <- kmult[kap]*Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
  MTcosts[kap, ] <-coef1*(Mass)^theta*(exp(-E/(k*(Temp+raiseT[kap])))) #
}#
 # plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 2600000), col=4)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=4)#
# lines(MTcosts[1, ], lty=1, col=1, lwd=2)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=1)#
# lines(MTcosts[1, ], lty=1, col=2, lwd=2)#
# Income = Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
#   #
#  plot(Income)#
#  #
# ###plot metabolic cost functions for each temp to check they are sensible#
 #  matplot( ((1:length(Mass))), t((MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab="Metabolic rate in J/season", col=c(4, 3, "orange", 2, "dark red"))    #
##################################################################################################################################################################################################
#DYNAMIC MODEL: life history in a single environment#
#
#dynamic behaviors#
u <-  seq(0, 1, by = 0.1) #fraction stored (rest allocated to structure)#
#
r<-  seq(0, 1, by = 0.1) #fraction allocated to reproduction (rest is saved)#
#set up arrays to store fitness values  #
MaxF=array(dim=c(Yindexmax, Lmax, phi, Tmax),data=-1) #this will store the max fitness for every combination of state and times#
MaxF[,,,Tmax]=0 #Fill fitness of Tmax column with 0#
Vmat=array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#Vmat is the fitness value of all possible actions#
Vmat[,,,,,]=rep(-1, length(Vmat))#
Cmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
Fmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#store optimal behaviors#
optU=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
optR=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
#the dynamic loop:#
i <- Tmax-1	#
for (i in (Tmax-1):1) { #where i is time (age) in months#
Y <- 1#
 for (Y in 1:Yindexmax) { #for all values of Energy Stores in loop (unJdensityd)#
  #setTxtProgressBar(pb, Y) #progress bar tracks which value of Y we are on#
  L <- Lmin#
   for (L in Lmin:Lmax) { #for all possible values of Length#
    p <- 1#
   for (p in 1:phi) { #for every temp environment#
     			spawning <- "NO"#
    		month = ((i-1) %% 12) + 1 #for the seasonality convert time in months to specific season-month (1-12)#
			 if (raiseT[month] > 0) spawning <- "YES"#
			          #############################
          #calculate the critical stored energy needed for this length to be viable #
            Wstructure<-a*L^3 #  find structural mass in kg#
            Estores <-   Jdensity*a*Lmax^3*(Y^3)*storemax/(Yindexmax^3)#
            EcritL <- Wstructure*storemin*Jdensity#
            EstoresmaxL <-Wstructure*storemax*Jdensity #following Chapman et al#
            if (Estores > EstoresmaxL)  Estores <- EstoresmaxL #stored energy (Estores) capped at the maximum allowed (60% of the structural body mass in J) #
	        #two loops over allocation strategies:#
	        g <- 1#
	        for (g in 1:length(u)) { #fractional placeholder (placeholder variable so we can loop over non-integers)#
	            growth = u[g] #Convert integer loop index to fractional value for allocation     #
	        for(h in 1:length(r)) { #where r is fractional allocation to reproductive effort	#
	             if (spawning == "YES") {#
	           reprod = r[h]  #Convert integer loop index to fractional value for allocation#
	               } else 	reprod = 0 #
	           #check if this combination of allocation is viable, and this number of stores is adequate for this length: #
		          if (growth + reprod > 1 )   Vmat[Y,L, p, i, g, h]	<- 0 else #
		            { #given the above conditions are met calculate all states:#
		                Wstores<-Estores/Jdensity  #stored mass in kG#
		                Wtotal <- Wstores+Wstructure  #body mass in KG#
		                Estructure <- Wstructure*Jdensity #body structure in Joules#
		                Rlimit <- Estructure*reprolimit #rlimit in Joules#
		                #future state calculations		              #
		                EstoresP <- Estores*(1-reprod-growth) +Income[month, L]*Jdensity - MTcosts[month, L] #combines mass-dependent food intake and mass-dependent metabolic costs#
		                EstructureP <- Estructure + growth*Estores#
		                #WstructureP <- Wstructure + growth*Estores/Jdensity #
		                LengthP <- (L^3 + growth*(Estores /(a*Jdensity)) )^(1/3)#
		                EstoresmaxLP <- EstructureP*storemax #
		                EstoresP <- min(EstoresP, EstoresmaxLP) # this statement caps stores max storage allowed for that size#
		                EstoresP <- max(EstoresP, 0)	 #if future stored energy is negative, it is cut off at zero.   #
		              ####Interpolation of future fitness between non-integer values of stored energy#
		                YP <- ((EstoresP*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3) #convert future stores to a future state index on the Y scale#
		                YP_floor <- floor(YP)#
		                 dx <- YP - YP_floor#
		              if (ceiling(LengthP) > Lmax) Lindex <- Lmax else#
		                Lindex <- ceiling(LengthP)#
		              if(YP_floor >= Yindexmax )#
		              {#
		                  FutureFitness <- MaxF[Yindexmax,Lindex,p,i+1] } else {#
		              	    	  FutureFitness <- dx*MaxF[YP_floor+1, Lindex, p, i+1]#
		              	  if(YP_floor > 0) FutureFitness <- FutureFitness + (1-dx)*MaxF[YP_floor,Lindex,p,i+1] #
		              } #end else if#
		                 if (reprod*Estores > Rlimit) {#
		                    RealizedR <- Rlimit } else {#
		                        RealizedR <- reprod*Estores#
		                    } #
		                Ecrit_survival <- 1 /(1 + exp(- q*(Estores - EcritL))) #
		                Rlimit_smooth <-  (reprod * Estores)  / (1 + ((reprod*Estores) / Rlimit)) #
		                Vmat[Y,L, p, i, g, h]	<-  (Rlimit_smooth  + exp(-mu[L])*FutureFitness )*Ecrit_survival#
		                #Cmat[Y,L, p, i, g, h] <- Rlimit_smooth*Ecrit_survival#
		                #Fmat[Y,L, p, i, g, h] <- exp(-mu[L])*FutureFitness*Ecrit_survival#
	            		  } #end else if growth + reprod < 1 and EcritL < Estores	  		#
	         		 } #end h loop#
	      			 } #end g loop#
        #find and store the highest fitness from growth and reproduction combinations given the other values for length, stored energy, and age#
        MaxF[Y,L,p,i] <-  max(Vmat[Y,L, p, i, , ])#
        if(MaxF[Y,L,p,i] == 0)#
        {#
          optU[Y, L,p,i]=-1#
          optR[Y, L,p,i]=0#
        } else {#
        #find out the differences in fitness of all strategies from the maximum, #
        #use the mean if a tie, record the difference for later error introduction:#
        nStrats = length(u) * length(r)#
        cursor = 0#
        mult_u <- rep(NA, nStrats)#
        mult_r <- rep(NA, nStrats)#
        for (g in 1:length(u)) {#
          for(h in 1:length(r)) {#
            if (MaxF[Y, L,p,i] == Vmat[Y,L, p, i, g, h]) {#
              cursor = cursor + 1#
              mult_u[cursor] <- u[g]	   #record all behaviors that have the same fitness as the max.         #
              mult_r[cursor] <- r[h]#
            }  #end if#
          } # end 2nd h loop  #
        } #end 2nd g loop#
        eqGrowth = mult_u[1:cursor]#
        eqRepro = mult_r[1:cursor]#
        smallestRepro = min(eqRepro)#
        largestGrowth = max(eqGrowth[eqRepro == smallestRepro])#
        #take mean of all behaviors with same fitness as max#
        optU[Y, L,p,i]=largestGrowth#
        optR[Y, L,p,i]=smallestRepro#
        }#
    }	#end p loop#
  } #end L loop#
} #end Y loop#
#
} #end i loop#
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")        #
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (reprod * state[index])  / (1 + ( reprod*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
reproduction
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")
library(fields)
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")
reproduction
size
sizedist
R
repro
(reprod * state[index])  / (1 + ( reprod*state[index]  /  Replim )
)
state
Replim
reprod * state[index])
reprod * state[index]
(repro * state[index])  / (1 + ( repro*state[index]  /  Replim ) )
(repro * state[index])  / (1 + ( repro*state[index]  /  Replim ) )/Jdensity
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (repro * state[index])  / (1 + ( repro*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
(repro * state[index])  / (1 + ( repro*state[index]  /  Replim ) )
rm(repro)
repro
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (repro * state[index])  / (1 + ( repro*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
(repro * state[index])  / (1 + ( repro*state[index]  /  Replim ) )
state
state[index]
repro
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (repro[index, i] * state[index])  / (1 + ( repro[index, i]*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
9*288.15 + 3(288.15+9)
9*288.15 + 3*(288.15+9)
9*288.15 + 3*(288.15+9) / 12
(9*288.15 + 3*(288.15+9)) / 12
#!/usr/bin/env Rscript --vanilla#
#install.packages("fields")#
# library(fields)#
#rm(list = ls(all = TRUE))#
#
set.seed(1001)#
filepath <- "~/Desktop/group3/"#
#filepath <- "~/Desktop/test/"#
seasons = "YES"#
#
 f_h <- 4/12#
#
timebin=12#
 Temp <- 288.15#
  reprolimit=0.2#
  Kappa = 8/12  #
  Tmax = 18*timebin  #monthly stime steps, maximum lifespan is 18 years#
#describe temperature dependent costs#
k=1.3e-23#
E = 1.04e-19#
theta=0.66#
 coef1  =5e+16 ##normalization constant puts tuna SMR in the same ballpark as the costs Kitchell et al. (1978) Bioenergetic spectra of skipjack and yellowfin tunas, pp 359 IN Sharp G.D. and Dizon A.E. eds. The Physiological Ecology of Tunas, Academic press.  #
#
#physiological parameters#
a <- 5e-5 #from ICCAT 2015 BFT length-weight relationship#
Jdensity <-  4.2e+6 #J/kg #from Chapman et al. 2011#
b=1.8#
d = 2.4#
#
#STATE VARIABLES#
phi <- 1 # only 1 environment#
Lmax <- 400  #maximum size of 4 meters#
Lmin <- 1 #
Yindexmax <- 100 #maximum index of stores in state loop  #
#
storemax= 0.6 #proportion of structural mass that individuals can devote to energy storage#
storemin = 0.1#
thresholdsize <- 20#
####################################################################################################################################################################################################
###Lookup Tables - look up costs and food functions so they are not calculated every time#
#
###Sizespectra allow us to descripbe prey preference, encounter, consumption to predict prey availability and mass-specific mortality:#
  #total mass maximum in kg#
##Prey availability   #
phi_a <- 3 #from table 2.2 in Andersen book#
lam <- 1.95#
K_c=10 #from Table 2.2, this changes with season (and is scaled by Kappa)#
##mass dependent mortality#
 phi_p <- 0.07 #from table 2.2 in Andersen book#
f_0 <- 0.6 #somewhere between 0 and 1, but predators rarely caught with totally full stomach#
hprime <- 17.2#
#coefficient on the consumption rate from table 2.2#
met_mort <- -0.25 #the argument in Andersen book is that mass-specific rates such as mortality Jdensitys with the metabolic esp of 3/4 (Brown et al. 2004). #
#
#steepness of penalty to survival near EcritL threshold state value#
q = 5e-5 #
####ADD SEASONALITY IN RESOURCES AND FOOD TO SOME MONTHS#
if(seasons == "NO") {	#
	kmult <-   rep(1, timebin)   #
	raiseT <-      rep(0, timebin)  	#
		} else {#
		#hardcoded for timebin = 12#
	kmult <-    c(rep(3, 9), rep(1, 3))  #currently short breeding season with low resources#
	raiseT <-   c(rep(0,9), rep(9, 3))#currently raise T from 15 to 24#
#
		} #end if #
#
Mass <- a*(Lmin:Lmax)^3 #
#
mu<- phi_p*f_h*Mass^met_mort #note we are excluding "background" mortality that is independent of size.... #
#
Income = matrix(nrow = timebin, ncol = length(Mass))#
MTcosts = matrix(nrow = timebin, ncol = length(Mass))#
#
for (kap in 1:timebin) {#
  Income[kap, ] <- kmult[kap]*Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
  MTcosts[kap, ] <-coef1*(Mass)^theta*(exp(-E/(k*(Temp+raiseT[kap])))) #
}#
 # plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 2600000), col=4)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=4)#
# lines(MTcosts[1, ], lty=1, col=1, lwd=2)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=1)#
# lines(MTcosts[1, ], lty=1, col=2, lwd=2)#
# Income = Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
#   #
#  plot(Income)#
#  #
# ###plot metabolic cost functions for each temp to check they are sensible#
 #  matplot( ((1:length(Mass))), t((MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab="Metabolic rate in J/season", col=c(4, 3, "orange", 2, "dark red"))    #
##################################################################################################################################################################################################
#DYNAMIC MODEL: life history in a single environment#
#
#dynamic behaviors#
u <-  seq(0, 1, by = 0.1) #fraction stored (rest allocated to structure)#
#
r<-  seq(0, 1, by = 0.1) #fraction allocated to reproduction (rest is saved)#
#set up arrays to store fitness values  #
MaxF=array(dim=c(Yindexmax, Lmax, phi, Tmax),data=-1) #this will store the max fitness for every combination of state and times#
MaxF[,,,Tmax]=0 #Fill fitness of Tmax column with 0#
Vmat=array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#Vmat is the fitness value of all possible actions#
Vmat[,,,,,]=rep(-1, length(Vmat))#
Cmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
Fmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#store optimal behaviors#
optU=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
optR=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
#the dynamic loop:#
i <- Tmax-1	#
for (i in (Tmax-1):1) { #where i is time (age) in months#
Y <- 1#
 for (Y in 1:Yindexmax) { #for all values of Energy Stores in loop (unJdensityd)#
  #setTxtProgressBar(pb, Y) #progress bar tracks which value of Y we are on#
  L <- Lmin#
   for (L in Lmin:Lmax) { #for all possible values of Length#
    p <- 1#
   for (p in 1:phi) { #for every temp environment#
     			spawning <- "NO"#
    		month = ((i-1) %% 12) + 1 #for the seasonality convert time in months to specific season-month (1-12)#
			 if (raiseT[month] > 0) spawning <- "YES"#
			          #############################
          #calculate the critical stored energy needed for this length to be viable #
            Wstructure<-a*L^3 #  find structural mass in kg#
            Estores <-   Jdensity*a*Lmax^3*(Y^3)*storemax/(Yindexmax^3)#
            EcritL <- Wstructure*storemin*Jdensity#
            EstoresmaxL <-Wstructure*storemax*Jdensity #following Chapman et al#
            if (Estores > EstoresmaxL)  Estores <- EstoresmaxL #stored energy (Estores) capped at the maximum allowed (60% of the structural body mass in J) #
	        #two loops over allocation strategies:#
	        g <- 1#
	        for (g in 1:length(u)) { #fractional placeholder (placeholder variable so we can loop over non-integers)#
	            growth = u[g] #Convert integer loop index to fractional value for allocation     #
	        for(h in 1:length(r)) { #where r is fractional allocation to reproductive effort	#
	             if (spawning == "YES") {#
	           reprod = r[h]  #Convert integer loop index to fractional value for allocation#
	               } else 	reprod = 0 #
	           #check if this combination of allocation is viable, and this number of stores is adequate for this length: #
		          if (growth + reprod > 1 )   Vmat[Y,L, p, i, g, h]	<- 0 else #
		            { #given the above conditions are met calculate all states:#
		                Wstores<-Estores/Jdensity  #stored mass in kG#
		                Wtotal <- Wstores+Wstructure  #body mass in KG#
		                Estructure <- Wstructure*Jdensity #body structure in Joules#
		                Rlimit <- Estructure*reprolimit #rlimit in Joules#
		                #future state calculations		              #
		                EstoresP <- Estores*(1-reprod-growth) +Income[month, L]*Jdensity - MTcosts[month, L] #combines mass-dependent food intake and mass-dependent metabolic costs#
		                EstructureP <- Estructure + growth*Estores#
		                #WstructureP <- Wstructure + growth*Estores/Jdensity #
		                LengthP <- (L^3 + growth*(Estores /(a*Jdensity)) )^(1/3)#
		                EstoresmaxLP <- EstructureP*storemax #
		                EstoresP <- min(EstoresP, EstoresmaxLP) # this statement caps stores max storage allowed for that size#
		                EstoresP <- max(EstoresP, 0)	 #if future stored energy is negative, it is cut off at zero.   #
		              ####Interpolation of future fitness between non-integer values of stored energy#
		                YP <- ((EstoresP*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3) #convert future stores to a future state index on the Y scale#
		                YP_floor <- floor(YP)#
		                 dx <- YP - YP_floor#
		              if (ceiling(LengthP) > Lmax) Lindex <- Lmax else#
		                Lindex <- ceiling(LengthP)#
		              if(YP_floor >= Yindexmax )#
		              {#
		                  FutureFitness <- MaxF[Yindexmax,Lindex,p,i+1] } else {#
		              	    	  FutureFitness <- dx*MaxF[YP_floor+1, Lindex, p, i+1]#
		              	  if(YP_floor > 0) FutureFitness <- FutureFitness + (1-dx)*MaxF[YP_floor,Lindex,p,i+1] #
		              } #end else if#
		                 if (reprod*Estores > Rlimit) {#
		                    RealizedR <- Rlimit } else {#
		                        RealizedR <- reprod*Estores#
		                    } #
		                Ecrit_survival <- 1 /(1 + exp(- q*(Estores - EcritL))) #
		                Rlimit_smooth <-  (reprod * Estores)  / (1 + ((reprod*Estores) / Rlimit)) #
		                Vmat[Y,L, p, i, g, h]	<-  (Rlimit_smooth  + exp(-mu[L])*FutureFitness )*Ecrit_survival#
		                #Cmat[Y,L, p, i, g, h] <- Rlimit_smooth*Ecrit_survival#
		                #Fmat[Y,L, p, i, g, h] <- exp(-mu[L])*FutureFitness*Ecrit_survival#
	            		  } #end else if growth + reprod < 1 and EcritL < Estores	  		#
	         		 } #end h loop#
	      			 } #end g loop#
        #find and store the highest fitness from growth and reproduction combinations given the other values for length, stored energy, and age#
        MaxF[Y,L,p,i] <-  max(Vmat[Y,L, p, i, , ])#
        if(MaxF[Y,L,p,i] == 0)#
        {#
          optU[Y, L,p,i]=-1#
          optR[Y, L,p,i]=0#
        } else {#
        #find out the differences in fitness of all strategies from the maximum, #
        #use the mean if a tie, record the difference for later error introduction:#
        nStrats = length(u) * length(r)#
        cursor = 0#
        mult_u <- rep(NA, nStrats)#
        mult_r <- rep(NA, nStrats)#
        for (g in 1:length(u)) {#
          for(h in 1:length(r)) {#
            if (MaxF[Y, L,p,i] == Vmat[Y,L, p, i, g, h]) {#
              cursor = cursor + 1#
              mult_u[cursor] <- u[g]	   #record all behaviors that have the same fitness as the max.         #
              mult_r[cursor] <- r[h]#
            }  #end if#
          } # end 2nd h loop  #
        } #end 2nd g loop#
        eqGrowth = mult_u[1:cursor]#
        eqRepro = mult_r[1:cursor]#
        smallestRepro = min(eqRepro)#
        largestGrowth = max(eqGrowth[eqRepro == smallestRepro])#
        #take mean of all behaviors with same fitness as max#
        optU[Y, L,p,i]=largestGrowth#
        optR[Y, L,p,i]=smallestRepro#
        }#
    }	#end p loop#
  } #end L loop#
} #end Y loop#
#
} #end i loop#
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")        #
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (repro[index, i] * state[index])  / (1 + ( repro[index, i]*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
#!/usr/bin/env Rscript --vanilla#
#install.packages("fields")#
# library(fields)#
#rm(list = ls(all = TRUE))#
#
set.seed(1001)#
filepath <- "~/Desktop/group3/"#
#filepath <- "~/Desktop/test/"#
seasons = "YES"#
#
 f_h <- 8/12#
#
timebin=12#
 Temp <- 288.15#
  reprolimit=0.2#
  Kappa = 4/12  #
  Tmax = 18*timebin  #monthly stime steps, maximum lifespan is 18 years#
#describe temperature dependent costs#
k=1.3e-23#
E = 1.04e-19#
theta=0.66#
 coef1  =5e+16 ##normalization constant puts tuna SMR in the same ballpark as the costs Kitchell et al. (1978) Bioenergetic spectra of skipjack and yellowfin tunas, pp 359 IN Sharp G.D. and Dizon A.E. eds. The Physiological Ecology of Tunas, Academic press.  #
#
#physiological parameters#
a <- 5e-5 #from ICCAT 2015 BFT length-weight relationship#
Jdensity <-  4.2e+6 #J/kg #from Chapman et al. 2011#
b=1.8#
d = 2.4#
#
#STATE VARIABLES#
phi <- 1 # only 1 environment#
Lmax <- 400  #maximum size of 4 meters#
Lmin <- 1 #
Yindexmax <- 100 #maximum index of stores in state loop  #
#
storemax= 0.6 #proportion of structural mass that individuals can devote to energy storage#
storemin = 0.1#
thresholdsize <- 20#
####################################################################################################################################################################################################
###Lookup Tables - look up costs and food functions so they are not calculated every time#
#
###Sizespectra allow us to descripbe prey preference, encounter, consumption to predict prey availability and mass-specific mortality:#
  #total mass maximum in kg#
##Prey availability   #
phi_a <- 3 #from table 2.2 in Andersen book#
lam <- 1.95#
K_c=10 #from Table 2.2, this changes with season (and is scaled by Kappa)#
##mass dependent mortality#
 phi_p <- 0.07 #from table 2.2 in Andersen book#
f_0 <- 0.6 #somewhere between 0 and 1, but predators rarely caught with totally full stomach#
hprime <- 17.2#
#coefficient on the consumption rate from table 2.2#
met_mort <- -0.25 #the argument in Andersen book is that mass-specific rates such as mortality Jdensitys with the metabolic esp of 3/4 (Brown et al. 2004). #
#
#steepness of penalty to survival near EcritL threshold state value#
q = 5e-5 #
####ADD SEASONALITY IN RESOURCES AND FOOD TO SOME MONTHS#
if(seasons == "NO") {	#
	kmult <-   rep(1, timebin)   #
	raiseT <-      rep(0, timebin)  	#
		} else {#
		#hardcoded for timebin = 12#
	kmult <-    c(rep(3, 9), rep(1, 3))  #currently short breeding season with low resources#
	raiseT <-   c(rep(0,9), rep(9, 3))#currently raise T from 15 to 24#
#
		} #end if #
#
Mass <- a*(Lmin:Lmax)^3 #
#
mu<- phi_p*f_h*Mass^met_mort #note we are excluding "background" mortality that is independent of size.... #
#
Income = matrix(nrow = timebin, ncol = length(Mass))#
MTcosts = matrix(nrow = timebin, ncol = length(Mass))#
#
for (kap in 1:timebin) {#
  Income[kap, ] <- kmult[kap]*Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
  MTcosts[kap, ] <-coef1*(Mass)^theta*(exp(-E/(k*(Temp+raiseT[kap])))) #
}#
 # plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 2600000), col=4)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=4)#
# lines(MTcosts[1, ], lty=1, col=1, lwd=2)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=1)#
# lines(MTcosts[1, ], lty=1, col=2, lwd=2)#
# Income = Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
#   #
#  plot(Income)#
#  #
# ###plot metabolic cost functions for each temp to check they are sensible#
 #  matplot( ((1:length(Mass))), t((MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab="Metabolic rate in J/season", col=c(4, 3, "orange", 2, "dark red"))    #
##################################################################################################################################################################################################
#DYNAMIC MODEL: life history in a single environment#
#
#dynamic behaviors#
u <-  seq(0, 1, by = 0.1) #fraction stored (rest allocated to structure)#
#
r<-  seq(0, 1, by = 0.1) #fraction allocated to reproduction (rest is saved)#
#set up arrays to store fitness values  #
MaxF=array(dim=c(Yindexmax, Lmax, phi, Tmax),data=-1) #this will store the max fitness for every combination of state and times#
MaxF[,,,Tmax]=0 #Fill fitness of Tmax column with 0#
Vmat=array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#Vmat is the fitness value of all possible actions#
Vmat[,,,,,]=rep(-1, length(Vmat))#
Cmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
Fmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#store optimal behaviors#
optU=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
optR=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
#the dynamic loop:#
i <- Tmax-1	#
for (i in (Tmax-1):1) { #where i is time (age) in months#
Y <- 1#
 for (Y in 1:Yindexmax) { #for all values of Energy Stores in loop (unJdensityd)#
  #setTxtProgressBar(pb, Y) #progress bar tracks which value of Y we are on#
  L <- Lmin#
   for (L in Lmin:Lmax) { #for all possible values of Length#
    p <- 1#
   for (p in 1:phi) { #for every temp environment#
     			spawning <- "NO"#
    		month = ((i-1) %% 12) + 1 #for the seasonality convert time in months to specific season-month (1-12)#
			 if (raiseT[month] > 0) spawning <- "YES"#
			          #############################
          #calculate the critical stored energy needed for this length to be viable #
            Wstructure<-a*L^3 #  find structural mass in kg#
            Estores <-   Jdensity*a*Lmax^3*(Y^3)*storemax/(Yindexmax^3)#
            EcritL <- Wstructure*storemin*Jdensity#
            EstoresmaxL <-Wstructure*storemax*Jdensity #following Chapman et al#
            if (Estores > EstoresmaxL)  Estores <- EstoresmaxL #stored energy (Estores) capped at the maximum allowed (60% of the structural body mass in J) #
	        #two loops over allocation strategies:#
	        g <- 1#
	        for (g in 1:length(u)) { #fractional placeholder (placeholder variable so we can loop over non-integers)#
	            growth = u[g] #Convert integer loop index to fractional value for allocation     #
	        for(h in 1:length(r)) { #where r is fractional allocation to reproductive effort	#
	             if (spawning == "YES") {#
	           reprod = r[h]  #Convert integer loop index to fractional value for allocation#
	               } else 	reprod = 0 #
	           #check if this combination of allocation is viable, and this number of stores is adequate for this length: #
		          if (growth + reprod > 1 )   Vmat[Y,L, p, i, g, h]	<- 0 else #
		            { #given the above conditions are met calculate all states:#
		                Wstores<-Estores/Jdensity  #stored mass in kG#
		                Wtotal <- Wstores+Wstructure  #body mass in KG#
		                Estructure <- Wstructure*Jdensity #body structure in Joules#
		                Rlimit <- Estructure*reprolimit #rlimit in Joules#
		                #future state calculations		              #
		                EstoresP <- Estores*(1-reprod-growth) +Income[month, L]*Jdensity - MTcosts[month, L] #combines mass-dependent food intake and mass-dependent metabolic costs#
		                EstructureP <- Estructure + growth*Estores#
		                #WstructureP <- Wstructure + growth*Estores/Jdensity #
		                LengthP <- (L^3 + growth*(Estores /(a*Jdensity)) )^(1/3)#
		                EstoresmaxLP <- EstructureP*storemax #
		                EstoresP <- min(EstoresP, EstoresmaxLP) # this statement caps stores max storage allowed for that size#
		                EstoresP <- max(EstoresP, 0)	 #if future stored energy is negative, it is cut off at zero.   #
		              ####Interpolation of future fitness between non-integer values of stored energy#
		                YP <- ((EstoresP*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3) #convert future stores to a future state index on the Y scale#
		                YP_floor <- floor(YP)#
		                 dx <- YP - YP_floor#
		              if (ceiling(LengthP) > Lmax) Lindex <- Lmax else#
		                Lindex <- ceiling(LengthP)#
		              if(YP_floor >= Yindexmax )#
		              {#
		                  FutureFitness <- MaxF[Yindexmax,Lindex,p,i+1] } else {#
		              	    	  FutureFitness <- dx*MaxF[YP_floor+1, Lindex, p, i+1]#
		              	  if(YP_floor > 0) FutureFitness <- FutureFitness + (1-dx)*MaxF[YP_floor,Lindex,p,i+1] #
		              } #end else if#
		                 if (reprod*Estores > Rlimit) {#
		                    RealizedR <- Rlimit } else {#
		                        RealizedR <- reprod*Estores#
		                    } #
		                Ecrit_survival <- 1 /(1 + exp(- q*(Estores - EcritL))) #
		                Rlimit_smooth <-  (reprod * Estores)  / (1 + ((reprod*Estores) / Rlimit)) #
		                Vmat[Y,L, p, i, g, h]	<-  (Rlimit_smooth  + exp(-mu[L])*FutureFitness )*Ecrit_survival#
		                #Cmat[Y,L, p, i, g, h] <- Rlimit_smooth*Ecrit_survival#
		                #Fmat[Y,L, p, i, g, h] <- exp(-mu[L])*FutureFitness*Ecrit_survival#
	            		  } #end else if growth + reprod < 1 and EcritL < Estores	  		#
	         		 } #end h loop#
	      			 } #end g loop#
        #find and store the highest fitness from growth and reproduction combinations given the other values for length, stored energy, and age#
        MaxF[Y,L,p,i] <-  max(Vmat[Y,L, p, i, , ])#
        if(MaxF[Y,L,p,i] == 0)#
        {#
          optU[Y, L,p,i]=-1#
          optR[Y, L,p,i]=0#
        } else {#
        #find out the differences in fitness of all strategies from the maximum, #
        #use the mean if a tie, record the difference for later error introduction:#
        nStrats = length(u) * length(r)#
        cursor = 0#
        mult_u <- rep(NA, nStrats)#
        mult_r <- rep(NA, nStrats)#
        for (g in 1:length(u)) {#
          for(h in 1:length(r)) {#
            if (MaxF[Y, L,p,i] == Vmat[Y,L, p, i, g, h]) {#
              cursor = cursor + 1#
              mult_u[cursor] <- u[g]	   #record all behaviors that have the same fitness as the max.         #
              mult_r[cursor] <- r[h]#
            }  #end if#
          } # end 2nd h loop  #
        } #end 2nd g loop#
        eqGrowth = mult_u[1:cursor]#
        eqRepro = mult_r[1:cursor]#
        smallestRepro = min(eqRepro)#
        largestGrowth = max(eqGrowth[eqRepro == smallestRepro])#
        #take mean of all behaviors with same fitness as max#
        optU[Y, L,p,i]=largestGrowth#
        optR[Y, L,p,i]=smallestRepro#
        }#
    }	#end p loop#
  } #end L loop#
} #end Y loop#
#
} #end i loop#
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")        #
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (repro[index, i] * state[index])  / (1 + ( repro[index, i]*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
#!/usr/bin/env Rscript --vanilla#
#install.packages("fields")#
# library(fields)#
#rm(list = ls(all = TRUE))#
#
set.seed(1001)#
filepath <- "~/Desktop/constant_test/"#
#filepath <- "~/Desktop/test/"#
seasons = "NO"#
#
 f_h <- 8/12#
#
timebin=12#
 Temp <- 288.15#
  reprolimit=0.2#
  Kappa = 4/12  #
  Tmax = 18*timebin  #monthly stime steps, maximum lifespan is 18 years#
#describe temperature dependent costs#
k=1.3e-23#
E = 1.04e-19#
theta=0.66#
 coef1  =5e+16 ##normalization constant puts tuna SMR in the same ballpark as the costs Kitchell et al. (1978) Bioenergetic spectra of skipjack and yellowfin tunas, pp 359 IN Sharp G.D. and Dizon A.E. eds. The Physiological Ecology of Tunas, Academic press.  #
#
#physiological parameters#
a <- 5e-5 #from ICCAT 2015 BFT length-weight relationship#
Jdensity <-  4.2e+6 #J/kg #from Chapman et al. 2011#
b=1.8#
d = 2.4#
#
#STATE VARIABLES#
phi <- 1 # only 1 environment#
Lmax <- 400  #maximum size of 4 meters#
Lmin <- 1 #
Yindexmax <- 100 #maximum index of stores in state loop  #
#
storemax= 0.6 #proportion of structural mass that individuals can devote to energy storage#
storemin = 0.1#
thresholdsize <- 20#
####################################################################################################################################################################################################
###Lookup Tables - look up costs and food functions so they are not calculated every time#
#
###Sizespectra allow us to descripbe prey preference, encounter, consumption to predict prey availability and mass-specific mortality:#
  #total mass maximum in kg#
##Prey availability   #
phi_a <- 3 #from table 2.2 in Andersen book#
lam <- 1.95#
K_c=10 #from Table 2.2, this changes with season (and is scaled by Kappa)#
##mass dependent mortality#
 phi_p <- 0.07 #from table 2.2 in Andersen book#
f_0 <- 0.6 #somewhere between 0 and 1, but predators rarely caught with totally full stomach#
hprime <- 17.2#
#coefficient on the consumption rate from table 2.2#
met_mort <- -0.25 #the argument in Andersen book is that mass-specific rates such as mortality Jdensitys with the metabolic esp of 3/4 (Brown et al. 2004). #
#
#steepness of penalty to survival near EcritL threshold state value#
q = 5e-5 #
####ADD SEASONALITY IN RESOURCES AND FOOD TO SOME MONTHS#
if(seasons == "NO") {	#
	kmult <-   rep(1, timebin)   #
	raiseT <-      rep(0, timebin)  	#
		} else {#
		#hardcoded for timebin = 12#
	kmult <-    c(rep(3, 9), rep(1, 3))  #currently short breeding season with low resources#
	raiseT <-   c(rep(0,9), rep(9, 3))#currently raise T from 15 to 24#
#
		} #end if #
#
Mass <- a*(Lmin:Lmax)^3 #
#
mu<- phi_p*f_h*Mass^met_mort #note we are excluding "background" mortality that is independent of size.... #
#
Income = matrix(nrow = timebin, ncol = length(Mass))#
MTcosts = matrix(nrow = timebin, ncol = length(Mass))#
#
for (kap in 1:timebin) {#
  Income[kap, ] <- kmult[kap]*Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
  MTcosts[kap, ] <-coef1*(Mass)^theta*(exp(-E/(k*(Temp+raiseT[kap])))) #
}#
 # plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 2600000), col=4)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=4)#
# lines(MTcosts[1, ], lty=1, col=1, lwd=2)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=1)#
# lines(MTcosts[1, ], lty=1, col=2, lwd=2)#
# Income = Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
#   #
#  plot(Income)#
#  #
# ###plot metabolic cost functions for each temp to check they are sensible#
 #  matplot( ((1:length(Mass))), t((MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab="Metabolic rate in J/season", col=c(4, 3, "orange", 2, "dark red"))    #
##################################################################################################################################################################################################
#DYNAMIC MODEL: life history in a single environment#
#
#dynamic behaviors#
u <-  seq(0, 1, by = 0.1) #fraction stored (rest allocated to structure)#
#
r<-  seq(0, 1, by = 0.1) #fraction allocated to reproduction (rest is saved)#
#set up arrays to store fitness values  #
MaxF=array(dim=c(Yindexmax, Lmax, phi, Tmax),data=-1) #this will store the max fitness for every combination of state and times#
MaxF[,,,Tmax]=0 #Fill fitness of Tmax column with 0#
Vmat=array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#Vmat is the fitness value of all possible actions#
Vmat[,,,,,]=rep(-1, length(Vmat))#
Cmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
Fmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#store optimal behaviors#
optU=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
optR=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
#the dynamic loop:#
i <- Tmax-1	#
for (i in (Tmax-1):1) { #where i is time (age) in months#
Y <- 1#
 for (Y in 1:Yindexmax) { #for all values of Energy Stores in loop (unJdensityd)#
  #setTxtProgressBar(pb, Y) #progress bar tracks which value of Y we are on#
  L <- Lmin#
   for (L in Lmin:Lmax) { #for all possible values of Length#
    p <- 1#
   for (p in 1:phi) { #for every temp environment#
     			spawning <- "NO"#
    		month = ((i-1) %% 12) + 1 #for the seasonality convert time in months to specific season-month (1-12)#
			 if (raiseT[month] > 0) spawning <- "YES"#
			          #############################
          #calculate the critical stored energy needed for this length to be viable #
            Wstructure<-a*L^3 #  find structural mass in kg#
            Estores <-   Jdensity*a*Lmax^3*(Y^3)*storemax/(Yindexmax^3)#
            EcritL <- Wstructure*storemin*Jdensity#
            EstoresmaxL <-Wstructure*storemax*Jdensity #following Chapman et al#
            if (Estores > EstoresmaxL)  Estores <- EstoresmaxL #stored energy (Estores) capped at the maximum allowed (60% of the structural body mass in J) #
	        #two loops over allocation strategies:#
	        g <- 1#
	        for (g in 1:length(u)) { #fractional placeholder (placeholder variable so we can loop over non-integers)#
	            growth = u[g] #Convert integer loop index to fractional value for allocation     #
	        for(h in 1:length(r)) { #where r is fractional allocation to reproductive effort	#
	             if (spawning == "YES") {#
	           reprod = r[h]  #Convert integer loop index to fractional value for allocation#
	               } else 	reprod = 0 #
	           #check if this combination of allocation is viable, and this number of stores is adequate for this length: #
		          if (growth + reprod > 1 )   Vmat[Y,L, p, i, g, h]	<- 0 else #
		            { #given the above conditions are met calculate all states:#
		                Wstores<-Estores/Jdensity  #stored mass in kG#
		                Wtotal <- Wstores+Wstructure  #body mass in KG#
		                Estructure <- Wstructure*Jdensity #body structure in Joules#
		                Rlimit <- Estructure*reprolimit #rlimit in Joules#
		                #future state calculations		              #
		                EstoresP <- Estores*(1-reprod-growth) +Income[month, L]*Jdensity - MTcosts[month, L] #combines mass-dependent food intake and mass-dependent metabolic costs#
		                EstructureP <- Estructure + growth*Estores#
		                #WstructureP <- Wstructure + growth*Estores/Jdensity #
		                LengthP <- (L^3 + growth*(Estores /(a*Jdensity)) )^(1/3)#
		                EstoresmaxLP <- EstructureP*storemax #
		                EstoresP <- min(EstoresP, EstoresmaxLP) # this statement caps stores max storage allowed for that size#
		                EstoresP <- max(EstoresP, 0)	 #if future stored energy is negative, it is cut off at zero.   #
		              ####Interpolation of future fitness between non-integer values of stored energy#
		                YP <- ((EstoresP*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3) #convert future stores to a future state index on the Y scale#
		                YP_floor <- floor(YP)#
		                 dx <- YP - YP_floor#
		              if (ceiling(LengthP) > Lmax) Lindex <- Lmax else#
		                Lindex <- ceiling(LengthP)#
		              if(YP_floor >= Yindexmax )#
		              {#
		                  FutureFitness <- MaxF[Yindexmax,Lindex,p,i+1] } else {#
		              	    	  FutureFitness <- dx*MaxF[YP_floor+1, Lindex, p, i+1]#
		              	  if(YP_floor > 0) FutureFitness <- FutureFitness + (1-dx)*MaxF[YP_floor,Lindex,p,i+1] #
		              } #end else if#
		                 if (reprod*Estores > Rlimit) {#
		                    RealizedR <- Rlimit } else {#
		                        RealizedR <- reprod*Estores#
		                    } #
		                Ecrit_survival <- 1 /(1 + exp(- q*(Estores - EcritL))) #
		                Rlimit_smooth <-  (reprod * Estores)  / (1 + ((reprod*Estores) / Rlimit)) #
		                Vmat[Y,L, p, i, g, h]	<-  (Rlimit_smooth  + exp(-mu[L])*FutureFitness )*Ecrit_survival#
		                #Cmat[Y,L, p, i, g, h] <- Rlimit_smooth*Ecrit_survival#
		                #Fmat[Y,L, p, i, g, h] <- exp(-mu[L])*FutureFitness*Ecrit_survival#
	            		  } #end else if growth + reprod < 1 and EcritL < Estores	  		#
	         		 } #end h loop#
	      			 } #end g loop#
        #find and store the highest fitness from growth and reproduction combinations given the other values for length, stored energy, and age#
        MaxF[Y,L,p,i] <-  max(Vmat[Y,L, p, i, , ])#
        if(MaxF[Y,L,p,i] == 0)#
        {#
          optU[Y, L,p,i]=-1#
          optR[Y, L,p,i]=0#
        } else {#
        #find out the differences in fitness of all strategies from the maximum, #
        #use the mean if a tie, record the difference for later error introduction:#
        nStrats = length(u) * length(r)#
        cursor = 0#
        mult_u <- rep(NA, nStrats)#
        mult_r <- rep(NA, nStrats)#
        for (g in 1:length(u)) {#
          for(h in 1:length(r)) {#
            if (MaxF[Y, L,p,i] == Vmat[Y,L, p, i, g, h]) {#
              cursor = cursor + 1#
              mult_u[cursor] <- u[g]	   #record all behaviors that have the same fitness as the max.         #
              mult_r[cursor] <- r[h]#
            }  #end if#
          } # end 2nd h loop  #
        } #end 2nd g loop#
        eqGrowth = mult_u[1:cursor]#
        eqRepro = mult_r[1:cursor]#
        smallestRepro = min(eqRepro)#
        largestGrowth = max(eqGrowth[eqRepro == smallestRepro])#
        #take mean of all behaviors with same fitness as max#
        optU[Y, L,p,i]=largestGrowth#
        optR[Y, L,p,i]=smallestRepro#
        }#
    }	#end p loop#
  } #end L loop#
} #end Y loop#
#
} #end i loop#
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")        #
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (repro[index, i] * state[index])  / (1 + ( repro[index, i]*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
#!/usr/bin/env Rscript --vanilla#
#install.packages("fields")#
# library(fields)#
#rm(list = ls(all = TRUE))#
#
set.seed(1001)#
filepath <- "~/Desktop/constant_test/"#
#filepath <- "~/Desktop/test/"#
seasons = "NO"#
#
 f_h <- 8/12#
#
timebin=12#
 Temp <- 288.15#
  reprolimit=0.2#
  Kappa = 4/12  #
  Tmax = 18*timebin  #monthly stime steps, maximum lifespan is 18 years#
#describe temperature dependent costs#
k=1.3e-23#
E = 1.04e-19#
theta=0.66#
 coef1  =5e+16 ##normalization constant puts tuna SMR in the same ballpark as the costs Kitchell et al. (1978) Bioenergetic spectra of skipjack and yellowfin tunas, pp 359 IN Sharp G.D. and Dizon A.E. eds. The Physiological Ecology of Tunas, Academic press.  #
#
#physiological parameters#
a <- 5e-5 #from ICCAT 2015 BFT length-weight relationship#
Jdensity <-  4.2e+6 #J/kg #from Chapman et al. 2011#
b=1.8#
d = 2.4#
#
#STATE VARIABLES#
phi <- 1 # only 1 environment#
Lmax <- 400  #maximum size of 4 meters#
Lmin <- 1 #
Yindexmax <- 100 #maximum index of stores in state loop  #
#
storemax= 0.6 #proportion of structural mass that individuals can devote to energy storage#
storemin = 0.1#
thresholdsize <- 20#
####################################################################################################################################################################################################
###Lookup Tables - look up costs and food functions so they are not calculated every time#
#
###Sizespectra allow us to descripbe prey preference, encounter, consumption to predict prey availability and mass-specific mortality:#
  #total mass maximum in kg#
##Prey availability   #
phi_a <- 3 #from table 2.2 in Andersen book#
lam <- 1.95#
K_c=10 #from Table 2.2, this changes with season (and is scaled by Kappa)#
##mass dependent mortality#
 phi_p <- 0.07 #from table 2.2 in Andersen book#
f_0 <- 0.6 #somewhere between 0 and 1, but predators rarely caught with totally full stomach#
hprime <- 17.2#
#coefficient on the consumption rate from table 2.2#
met_mort <- -0.25 #the argument in Andersen book is that mass-specific rates such as mortality Jdensitys with the metabolic esp of 3/4 (Brown et al. 2004). #
#
#steepness of penalty to survival near EcritL threshold state value#
q = 5e-5 #
####ADD SEASONALITY IN RESOURCES AND FOOD TO SOME MONTHS#
if(seasons == "NO") {	#
	kmult <-   rep(1, timebin)   #
	raiseT <-      rep(0, timebin)  	#
		} else {#
		#hardcoded for timebin = 12#
	kmult <-    c(rep(3, 9), rep(1, 3))  #currently short breeding season with low resources#
	raiseT <-   c(rep(0,9), rep(9, 3))#currently raise T from 15 to 24#
#
		} #end if #
#
Mass <- a*(Lmin:Lmax)^3 #
#
mu<- phi_p*f_h*Mass^met_mort #note we are excluding "background" mortality that is independent of size.... #
#
Income = matrix(nrow = timebin, ncol = length(Mass))#
MTcosts = matrix(nrow = timebin, ncol = length(Mass))#
#
for (kap in 1:timebin) {#
  Income[kap, ] <- kmult[kap]*Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
  MTcosts[kap, ] <-coef1*(Mass)^theta*(exp(-E/(k*(Temp+raiseT[kap])))) #
}#
 # plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 2600000), col=4)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=4)#
# lines(MTcosts[1, ], lty=1, col=1, lwd=2)#
# plot(MTcosts[7, ], type="l", ylab="Monthly Metabolic Costs (J)", xaxt="n", lwd=5, ylim=c(0, 7800000), col=1)#
# lines(MTcosts[1, ], lty=1, col=2, lwd=2)#
# Income = Kappa*phi_a*K_c*Mass^(2-lam) #this describes the scaling with size and ecostystem richness#
#   #
#  plot(Income)#
#  #
# ###plot metabolic cost functions for each temp to check they are sensible#
 #  matplot( ((1:length(Mass))), t((MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab="Metabolic rate in J/season", col=c(4, 3, "orange", 2, "dark red"))    #
##################################################################################################################################################################################################
#DYNAMIC MODEL: life history in a single environment#
#
#dynamic behaviors#
u <-  seq(0, 1, by = 0.1) #fraction stored (rest allocated to structure)#
#
r<-  seq(0, 1, by = 0.1) #fraction allocated to reproduction (rest is saved)#
#set up arrays to store fitness values  #
MaxF=array(dim=c(Yindexmax, Lmax, phi, Tmax),data=-1) #this will store the max fitness for every combination of state and times#
MaxF[,,,Tmax]=0 #Fill fitness of Tmax column with 0#
Vmat=array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#Vmat is the fitness value of all possible actions#
Vmat[,,,,,]=rep(-1, length(Vmat))#
Cmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
Fmat<- array(dim=c(Yindexmax, Lmax, phi, Tmax-1, length(u), length(r) ))#
#store optimal behaviors#
optU=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
optR=array(dim=c(Yindexmax, Lmax, phi, Tmax-1))#
#the dynamic loop:#
i <- Tmax-1	#
for (i in (Tmax-1):1) { #where i is time (age) in months#
Y <- 1#
 for (Y in 1:Yindexmax) { #for all values of Energy Stores in loop (unJdensityd)#
  #setTxtProgressBar(pb, Y) #progress bar tracks which value of Y we are on#
  L <- Lmin#
   for (L in Lmin:Lmax) { #for all possible values of Length#
    p <- 1#
   for (p in 1:phi) { #for every temp environment#
     			spawning <- "NO"#
    		month = ((i-1) %% 12) + 1 #for the seasonality convert time in months to specific season-month (1-12)#
			 if (raiseT[month] > 0 | seasons == "NO") spawning <- "YES"#
			          #############################
          #calculate the critical stored energy needed for this length to be viable #
            Wstructure<-a*L^3 #  find structural mass in kg#
            Estores <-   Jdensity*a*Lmax^3*(Y^3)*storemax/(Yindexmax^3)#
            EcritL <- Wstructure*storemin*Jdensity#
            EstoresmaxL <-Wstructure*storemax*Jdensity #following Chapman et al#
            if (Estores > EstoresmaxL)  Estores <- EstoresmaxL #stored energy (Estores) capped at the maximum allowed (60% of the structural body mass in J) #
	        #two loops over allocation strategies:#
	        g <- 1#
	        for (g in 1:length(u)) { #fractional placeholder (placeholder variable so we can loop over non-integers)#
	            growth = u[g] #Convert integer loop index to fractional value for allocation     #
	        for(h in 1:length(r)) { #where r is fractional allocation to reproductive effort	#
	             if (spawning == "YES") {#
	           reprod = r[h]  #Convert integer loop index to fractional value for allocation#
	               } else 	reprod = 0 #
	           #check if this combination of allocation is viable, and this number of stores is adequate for this length: #
		          if (growth + reprod > 1 )   Vmat[Y,L, p, i, g, h]	<- 0 else #
		            { #given the above conditions are met calculate all states:#
		                Wstores<-Estores/Jdensity  #stored mass in kG#
		                Wtotal <- Wstores+Wstructure  #body mass in KG#
		                Estructure <- Wstructure*Jdensity #body structure in Joules#
		                Rlimit <- Estructure*reprolimit #rlimit in Joules#
		                #future state calculations		              #
		                EstoresP <- Estores*(1-reprod-growth) +Income[month, L]*Jdensity - MTcosts[month, L] #combines mass-dependent food intake and mass-dependent metabolic costs#
		                EstructureP <- Estructure + growth*Estores#
		                #WstructureP <- Wstructure + growth*Estores/Jdensity #
		                LengthP <- (L^3 + growth*(Estores /(a*Jdensity)) )^(1/3)#
		                EstoresmaxLP <- EstructureP*storemax #
		                EstoresP <- min(EstoresP, EstoresmaxLP) # this statement caps stores max storage allowed for that size#
		                EstoresP <- max(EstoresP, 0)	 #if future stored energy is negative, it is cut off at zero.   #
		              ####Interpolation of future fitness between non-integer values of stored energy#
		                YP <- ((EstoresP*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3) #convert future stores to a future state index on the Y scale#
		                YP_floor <- floor(YP)#
		                 dx <- YP - YP_floor#
		              if (ceiling(LengthP) > Lmax) Lindex <- Lmax else#
		                Lindex <- ceiling(LengthP)#
		              if(YP_floor >= Yindexmax )#
		              {#
		                  FutureFitness <- MaxF[Yindexmax,Lindex,p,i+1] } else {#
		              	    	  FutureFitness <- dx*MaxF[YP_floor+1, Lindex, p, i+1]#
		              	  if(YP_floor > 0) FutureFitness <- FutureFitness + (1-dx)*MaxF[YP_floor,Lindex,p,i+1] #
		              } #end else if#
		                 if (reprod*Estores > Rlimit) {#
		                    RealizedR <- Rlimit } else {#
		                        RealizedR <- reprod*Estores#
		                    } #
		                Ecrit_survival <- 1 /(1 + exp(- q*(Estores - EcritL))) #
		                Rlimit_smooth <-  (reprod * Estores)  / (1 + ((reprod*Estores) / Rlimit)) #
		                Vmat[Y,L, p, i, g, h]	<-  (Rlimit_smooth  + exp(-mu[L])*FutureFitness )*Ecrit_survival#
		                #Cmat[Y,L, p, i, g, h] <- Rlimit_smooth*Ecrit_survival#
		                #Fmat[Y,L, p, i, g, h] <- exp(-mu[L])*FutureFitness*Ecrit_survival#
	            		  } #end else if growth + reprod < 1 and EcritL < Estores	  		#
	         		 } #end h loop#
	      			 } #end g loop#
        #find and store the highest fitness from growth and reproduction combinations given the other values for length, stored energy, and age#
        MaxF[Y,L,p,i] <-  max(Vmat[Y,L, p, i, , ])#
        if(MaxF[Y,L,p,i] == 0)#
        {#
          optU[Y, L,p,i]=-1#
          optR[Y, L,p,i]=0#
        } else {#
        #find out the differences in fitness of all strategies from the maximum, #
        #use the mean if a tie, record the difference for later error introduction:#
        nStrats = length(u) * length(r)#
        cursor = 0#
        mult_u <- rep(NA, nStrats)#
        mult_r <- rep(NA, nStrats)#
        for (g in 1:length(u)) {#
          for(h in 1:length(r)) {#
            if (MaxF[Y, L,p,i] == Vmat[Y,L, p, i, g, h]) {#
              cursor = cursor + 1#
              mult_u[cursor] <- u[g]	   #record all behaviors that have the same fitness as the max.         #
              mult_r[cursor] <- r[h]#
            }  #end if#
          } # end 2nd h loop  #
        } #end 2nd g loop#
        eqGrowth = mult_u[1:cursor]#
        eqRepro = mult_r[1:cursor]#
        smallestRepro = min(eqRepro)#
        largestGrowth = max(eqGrowth[eqRepro == smallestRepro])#
        #take mean of all behaviors with same fitness as max#
        optU[Y, L,p,i]=largestGrowth#
        optR[Y, L,p,i]=smallestRepro#
        }#
    }	#end p loop#
  } #end L loop#
} #end Y loop#
#
} #end i loop#
quartz()#
par(mfrow=c(3,2))#
gcol=     c("orange", two.colors(n=10, start="white", middle="gray", end="black"))#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,1]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,1]),     ylab="State", xlab="Length", main="reproduction")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-20)]),      ylab="State", xlab="Length", main="growth Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-20)]),    ylab="State", xlab="Length", main="reproduction Tmax-20")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optU[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="growth")       #
#
image.plot(1:Lmax, 1:Yindexmax, t(optR[,, 1,(Tmax-1)]),     ylab="State", xlab="Length", main="reproduction")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,100, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 100 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,100, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 100 cm")        #
image.plot( 1:(Tmax-1), 1:Yindexmax, t(optU[,200, 1,]),     ylab="State", xlab="Age (months)", main="growth for L = 200 cm")       #
#
image.plot(  1:(Tmax-1), 1:Yindexmax, t(optR[,200, 1,]),     ylab="State", xlab="Age (months)", main="reproduction for L = 200 cm")        #
set.seed(2001)#
nindiv=2  #
Ngroups=1#
group=1#
#
initialsize <- rep(5,  2) #as.integer(rnorm(nindiv, mean=50, sd=2.5))#
alive=matrix(ncol = Tmax, nrow= Ngroups, data=0)#
#
idist=matrix(data=NA, nrow=nindiv, ncol=Tmax) #keeps track of energetic state over time#
sizedist=matrix(data=NA, nrow=nindiv, ncol=Tmax)#
g_allo= array(dim=c(nindiv, Tmax), data = 0 )#
repro= array(dim=c(nindiv, Tmax), data = 0 ) #
income=array(dim=c(nindiv, Tmax), data = 0 )#
#these will give storage fraction and reproduction for each individual, given its two states at each time#
#
#z=rnorm(nindiv, mean=Jdensity*a*initialsize^3*(storemax - 0.05), sd=0) ## Generate a population (z) of indivdiuals, condition based on weight  (95% of max for size, with some variation)#
z<-  Jdensity*a*Lmax^3/(Yindexmax^3) #fixed initial state#
idist[,1]=ceiling(z) #this rounds every z up to the nearest integer for the first time step  #
 sizedist[,1]<- initialsize   #
#stores number of survivors at each time#
#
reproduction=matrix(0, nindiv, Tmax) #stores how much they reproduce at each time. #
#
#draw random numbers for every individual's survival chance at every time (compare randroaw to exp(-mu))  #
randraw=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
randraw2=matrix(runif(nindiv*(Tmax), max=1, min=0), nrow=nindiv, ncol=Tmax)#
normdraw=matrix(rnorm(nindiv*(Tmax), mean=1, sd=0.005), nrow=nindiv, ncol=Tmax) #add stochasticity in food intake#
#
survival=rep(0, Tmax)#
survival[1]<-1#
#
	for (i in 1:(Tmax-1)) { #
	   month = ((i-1) %% 12) + 1 #
	   state  <- idist[,i] #in Joules#
	   size <- round(sizedist[,i])  #in cm#
	   EcritL <-  Jdensity*a*size^3*storemin   #find the critical value of state, in joules, neede dfor a fish this size#
	   index <- which(state > EcritL) #which individuals are still alive (didn't starve)#
	    #now calculate Wtotal, Costs, and Net energy intake#
	   Wstructure<- a*size[index]^3 #structural mass in kilograms #
	   Estructure <- Wstructure*Jdensity #structural energy in joules#
	     Replim <- reprolimit*Estructure #
	   EstoresmaxL <-Estructure*storemax #find the maximum jules of energy that can be stored for fish of this length  #
	   state[index] <- ifelse(state[index] > EstoresmaxL, EstoresmaxL, state[index]) #stored energy capped at a certain body size#
	   Wstores<-state[index]/Jdensity#
	   Wtotal <-  Wstores+Wstructure   #body mass#
	       if(length(index) > 1) {#
		    ##find interpolated behaviors#
	         #first convert state to the Y index value it corresponds to and find the lower integer (floor)#
		    Estores = ((state[index]*Yindexmax^3)/((Jdensity*a*Lmax^3)*storemax))^(1/3)#
	         Ilo <- floor(Estores)#
		    #make sure it's not the maximum value that Y index can be#
		    Ilo <- ifelse(Ilo >= Yindexmax, Yindexmax-1, Ilo)   #
		    # then assuming it's not at the maximum, find the remainder and store it#
		    dx <- ifelse(Ilo >= Yindexmax, 1, Estores - Ilo) #
		    ##NOW WE NEED TO LOOK UP THE OPTIMAL BEHAVIORS FROM THE BACKWARD SOLUTION#
		    #We use the interpotion of state to find the allocation strategies  regardless of whether they survive  (since they allocate first) #
		    #create and index of low-state individuals where the Yindex value is between 0 and 1)#
		    condind <- Ilo == 0#
		    ##   if state is between 0 and 1 (Ilo = 0)the strategy is only dx*(state=1)#
		    g_allo[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optU[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1)  #
		    repro[index[condind==TRUE], i] <- round((dx[condind==TRUE])*diag(optR[Ilo[condind==TRUE]+1, size[index[condind==TRUE]], p, i]),1) #
		    ##if state is greater than 1 then we add (1-dx) by the lower state#
		    g_allo[index[condind==FALSE], i] <- round((1-dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) + #
		                                                (dx[condind==FALSE])*diag(optU[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1)  #
		    repro[index[condind==FALSE], i] <-round((1-dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE], size[index[condind==FALSE]], p, i]) +  #
		                                              (dx[condind==FALSE])*diag(optR[Ilo[condind==FALSE]+1, size[index[condind==FALSE]], p, i]),1	)	  					  #
		    # REPRODUCE AND GROW BEFORE SURVIAL IS DETERMINED    #
		    reproduction[index, i]<-  (repro[index, i] * state[index])  / (1 + ( repro[index, i]*state[index]  /  Replim ) )#
		    nextsize <-   (size[index]^3 +  g_allo[index,i]*(state[index] /(a*Jdensity)) )^(1/3)#
		    #survival <- randraw[index,i] <= exp(-mu[size[index]]) #
		    ##########################
		    survival[i+1] <- survival[i]*exp(-mu[size[index[1]]]) #this stores the cumulative probability an individual survives to age i+1#
		    #right now all individuals survive, we are not doing the randraw comparison#
		    #future state calculation:#
		    idist[index,i+1] <- (1-repro[index, i]-g_allo[index,i])*state[index] + Income[month, size[index]]*Jdensity - MTcosts[month, size[index]] #
		    sizedist[index, i+1] <- nextsize#
		    #alive[group, i+1]=sum(idist[,i+1] > 0, na.rm=TRUE) #number of survivors#
	 	    } #end if#
		}     #end time (i) loop#
#
	x1=3*timebin+1#
	y1= (colSums(alive))[x1]#
	x2=4*timebin #
	y2=(colSums(alive))[x2]#
#
#reproduction[, -Tmax]<-ifelse(reproduction[, -Tmax]>0,  reproduction[, -Tmax], NA)#
#
idist[, -Tmax]<-ifelse(idist[, -Tmax]>0,  idist[, -Tmax], NA)#
write.csv(idist, file=paste0(filepath,"03State", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p, "Kappa", round(Kappa,2), "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(sizedist, file=paste0(filepath,"01Length","Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))#
write.csv(reproduction, file=paste0(filepath,"02Repro", "Temp", Temp, "f_h", round(f_h, 2),  "phi_p", phi_p, "Kappa", round(Kappa,2),  "reprolimit", reprolimit, "Tmax", Tmax, ".csv")) #
write.csv(survival, file=paste0(filepath,"04Surv", "Temp", Temp, "f_h", round(f_h, 2), "phi_p", phi_p,  "Kappa", round(Kappa,2),   "reprolimit", reprolimit, "Tmax", Tmax, ".csv"))
288.15+9
# install.packages("ggplot2")#
library(ggplot2)#
#
Tmax=18#
time=1:(Tmax*12)#
###Functions to summarize and plot model data to check#
plot_length <- function(data, filenames) {#
  quartz()#
  matplot(t(data[,-1]), type="l", main=substr(filenames, 41, 53), col="darkgray", lwd=1.75, lty=1,  ylab="Length (cm)", ylim=c(0, 400), xlim=c(0.5, Tmax*12), xlab= "Age (years)", xaxt="n")#
  axis(1, at = seq(0, (Tmax)*12, by=12), labels = (seq(1, Tmax+1, by=1)))#
  maxsize <- (min(which(as.numeric(data[1, (2:215)]) == max(as.numeric(data[1, (2:215)]))))) + 1 #
  #print(data[1, maxsize])#
   #age_m <- min(which(as.numeric(data[1, -1]) >= 0.5*as.numeric(data[1, maxsize])))/12 #
   legend("topleft", legend=paste0("Lmax is ", round(data[1, maxsize]), " cm"), bty="n")#
   return(data[1, maxsize])#
}
setwd("/Users/hollykindsvater/Documents/size-spectra-life-history/Model_output/Results_Supp_Fig5/")#
  data_files <- list.files(pattern = "\\.csv$")#
  length_filenames <- data_files[1:(length(data_files) / 4)]#
repro_filenames <-#
  data_files[((length(data_files) / 4) + 1):(2 * (length(data_files) / 4))]#
state_filenames <-#
  data_files[(2 * (length(data_files) / 4) + 1):(3 * (length(data_files) /#
                                                        4))]#
#
surv_filenames <-#
  data_files[(3 * (length(data_files) / 4) + 1):(4 * (length(data_files) /#
                                                        4))]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
surv_filenames <- unique(surv_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)#
surv_data <- lapply(surv_filenames, read.csv)#
quartz()#
par(mfrow=c(2,3))#
 mapply(plot_length, length_data,  length_filenames)
plot_length <- function(data, filenames) {#
     matplot(t(data[,-1]), type="l", main=substr(filenames, 41, 53), col="darkgray", lwd=1.75, lty=1,  ylab="Length (cm)", ylim=c(0, 400), xlim=c(0.5, Tmax*12), xlab= "Age (years)", xaxt="n")#
  axis(1, at = seq(0, (Tmax)*12, by=12), labels = (seq(1, Tmax+1, by=1)))#
  maxsize <- (min(which(as.numeric(data[1, (2:215)]) == max(as.numeric(data[1, (2:215)]))))) + 1 #
  #print(data[1, maxsize])#
   #age_m <- min(which(as.numeric(data[1, -1]) >= 0.5*as.numeric(data[1, maxsize])))/12 #
   legend("topleft", legend=paste0("Lmax is ", round(data[1, maxsize]), " cm"), bty="n")#
   return(data[1, maxsize])#
}
setwd("/Users/hollykindsvater/Documents/size-spectra-life-history/Model_output/Results_Supp_Fig5/")#
  data_files <- list.files(pattern = "\\.csv$")#
  length_filenames <- data_files[1:(length(data_files) / 4)]#
repro_filenames <-#
  data_files[((length(data_files) / 4) + 1):(2 * (length(data_files) / 4))]#
state_filenames <-#
  data_files[(2 * (length(data_files) / 4) + 1):(3 * (length(data_files) /#
                                                        4))]#
#
surv_filenames <-#
  data_files[(3 * (length(data_files) / 4) + 1):(4 * (length(data_files) /#
                                                        4))]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
surv_filenames <- unique(surv_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)#
surv_data <- lapply(surv_filenames, read.csv)#
quartz()#
par(mfrow=c(2,3))#
 mapply(plot_length, length_data,  length_filenames)
setwd("/Users/hollykindsvater/Documents/size-spectra-life-history/Model_output/Results_Supp_Fig5/")#
  data_files <- list.files(pattern = "\\.csv$")#
  length_filenames <- data_files[1:(length(data_files) / 4)]#
repro_filenames <-#
  data_files[((length(data_files) / 4) + 1):(2 * (length(data_files) / 4))]#
state_filenames <-#
  data_files[(2 * (length(data_files) / 4) + 1):(3 * (length(data_files) /#
                                                        4))]#
#
surv_filenames <-#
  data_files[(3 * (length(data_files) / 4) + 1):(4 * (length(data_files) /#
                                                        4))]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
surv_filenames <- unique(surv_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)#
surv_data <- lapply(surv_filenames, read.csv)#
quartz()#
par(mfrow=c(2,3))#
 mapply(plot_length, length_data,  length_filenames)
